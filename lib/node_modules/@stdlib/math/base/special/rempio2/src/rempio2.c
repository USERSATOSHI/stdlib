/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/e_rem_pio2.c}. The implementation follows the original, but has been modified according to project conventions
*
* ```text
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
*
* Optimized by Bruce D. Evans.
* ```
*/


#include "stdlib/math/base/special/rempio2.h"
#include "stdlib/math/base/special/floor.h"
#include "stdlib/math/base/special/ldexp.h"

/* Table of constants for 2/pi */
static const int32_t ipio2[] = {
    0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,
    0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,
    0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,
    0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,
    0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,
    0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,
    0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,
    0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,
    0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,
    0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,
    0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B};

/* Double precision array, obtained by cutting pi/2 into 24 bits chunks */
static const double pio2[] = {
    1.57079625129699707031e+00, /* 0x3FF921FB, 0x40000000 */
    7.54978941586159635335e-08, /* 0x3E74442D, 0x00000000 */
    5.39030252995776476554e-15, /* 0x3CF84698, 0x80000000 */
    3.28200341580791294123e-22, /* 0x3B78CC51, 0x60000000 */
    1.27065575308067607349e-29, /* 0x39F01B83, 0x80000000 */
    1.22933308981111328932e-36, /* 0x387A2520, 0x40000000 */
    2.73370053816464559624e-44, /* 0x36E38222, 0x80000000 */
    2.16741683877804819444e-51  /* 0x3569F31D, 0x00000000 */
};

#define TWO24 (1.67772160000000000000e+07)  /* 0x41700000, 0x00000000 */
#define TWON24 (5.96046447753906250000e-08) /* 0x3E700000, 0x00000000 */

static int32_t F[20] = {0};
static int32_t Q[20] = {0};
static int32_t IQ[20] = {0};
static double FQ[20] = {0.0};

static int32_t compute(double x[], double y[], int32_t jz, int32_t q[], int32_t q0, int32_t jk, int32_t jv, int32_t jx, double f[])
{
    int32_t carry, fw, ih, jp, i, k, n, j, z;

    jp = jk;

    /* Distill q[] into IQ[] in reverse order */
    z = q[jz];
    j = jz;
    for (i = 0; j > 0; i++)
    {
        fw = (int32_t)(TWON24 * z);
        IQ[i] = (int32_t)(z - (TWO24 * fw));
        z = q[j - 1] + fw;
        j--;
    }

    /* Compute n */
    z = ldexp(z, q0);
    z -= 8.0 * floor(z * 0.125); /* Trim off integer >= 8 */
    n = (int32_t)z;
    z -= n;
    ih = 0;
    if (q0 > 0)
    {
        /* Need IQ[jz-1] to determine n */
        i = (IQ[jz - 1] >> (24 - q0));
        n += i;
        IQ[jz - 1] -= (i << (24 - q0));
        ih = (IQ[jz - 1] >> (23 - q0));
    }
    else if (q0 == 0)
    {
        ih = (IQ[jz - 1] >> 23);
    }
    else if (z >= 0.5)
    {
        ih = 2;
    }

    /* Case: q > 0.5 */
    if (ih > 0)
    {
        n += 1;
        carry = 0;

        /* Compute 1-q */
        for (i = 0; i < jz; i++)
        {
            j = IQ[i];
            if (carry == 0)
            {
                if (j != 0)
                {
                    carry = 1;
                    IQ[i] = 0x1000000 - j;
                }
            }
            else
            {
                IQ[i] = 0xffffff - j;
            }
        }
        if (q0 > 0)
        {
            /* Rare case: chance is 1 in 12 */
            switch (q0)
            {
            case 1:
                IQ[jz - 1] &= 0x7fffff;
                break;
            case 2:
                IQ[jz - 1] &= 0x3fffff;
                break;
            }
        }
        if (ih == 2)
        {
            z = 1.0 - z;
            if (carry != 0)
            {
                z -= ldexp(1.0, q0);
            }
        }
    }

    /* Check if re-computation is needed */
    if (z == 0.0)
    {
        j = 0;
        for (i = jz - 1; i >= jk; i--)
        {
            j |= IQ[i];
        }
        if (j == 0)
        {
            /* Need re-computation */
            for (k = 1; IQ[jk - k] == 0; k++)
            {
                /* k is the number of terms needed */
            }
            for (i = jz + 1; i <= jz + k; i++)
            {
                /* Add q[jz+1] to q[jz+k] */
                f[jx + i] = (double)ipio2[jv + i];
                double fw = 0.0;
                for (j = 0; j <= jx; j++)
                {
                    fw += x[j] * f[jx + (i - j)];
                }
                q[i] = (int32_t)fw;
            }
            jz += k;
            return compute(x, y, jz, q, q0, jk, jv, jx, f);
        }
    }

    /* Chop off zero terms */
    if (z == 0.0)
    {
        jz--;
        q0 -= 24;
        while (IQ[jz] == 0)
        {
            jz--;
            q0 -= 24;
        }
    }
    else
    {
        /* Break z into 24-bit if necessary */
        z = ldexp(z, -q0);
        if (z >= TWO24)
        {
            fw = (int32_t)(TWON24 * z);
            IQ[jz] = (int32_t)(z - (TWO24 * fw));
            jz++;
            q0 += 24;
            IQ[jz] = fw;
        }
        else
        {
            IQ[jz] = (int32_t)z;
        }
    }

    /* Convert integer "bit" chunk to floating-point value */
    double fw = ldexp(1.0, q0);
    for (i = jz; i >= 0; i--)
    {
        q[i] = (int32_t)(fw * IQ[i]);
        fw *= TWON24;
    }

    /* Compute PIO2[0,...,jp]*q[jz,...,0] */
    for (i = jz; i >= 0; i--)
    {
        double fw = 0.0;
        for (k = 0; k <= jp && k <= jz - i; k++)
        {
            fw += pio2[k] * q[i + k];
        }
        FQ[jz - i] = fw;
    }

    /* Compress FQ[] into y[] */
    double fw = 0.0;
    for (i = jz; i >= 0; i--)
    {
        fw += FQ[i];
    }
    if (ih == 0)
    {
        y[0] = fw;
    }
    else
    {
        y[0] = -fw;
    }
    fw = FQ[0] - fw;
    for (i = 1; i <= jz; i++)
    {
        fw += FQ[i];
    }
    if (ih == 0)
    {
        y[1] = fw;
    }
    else
    {
        y[1] = -fw;
    }

    return n & 7;
}

int32_t kernel_rempio2(double x[], double y[], int32_t e0, int32_t nx)
{
    int32_t jk, jv, jx, jz, q0, i, j, m;
    double fw;

    /* Initialize jk for double-precision floating-point numbers */
    jk = 4;

    /* Determine jx, jv, q0 (note that q0 < 3) */
    jx = nx - 1;
    jv = (e0 - 3) / 24;
    if (jv < 0)
    {
        jv = 0;
    }
    q0 = e0 - (24 * (jv + 1));

    /* Set up F[0] to F[jx+jk] where F[jx+jk] = IPIO2[jv+jk] */
    j = jv - jx;
    m = jx + jk;
    for (i = 0; i <= m; i++)
    {
        if (j < 0)
        {
            F[i] = 0;
        }
        else
        {
            F[i] = ipio2[j];
        }
        j++;
    }

    /* Compute Q[0], Q[1], ..., Q[jk] */
    for (i = 0; i <= jk; i++)
    {
        fw = 0.0;
        for (j = 0; j <= jx; j++)
        {
            fw += x[j] * F[jx + (i - j)];
        }
        Q[i] = (int32_t)fw;
    }

    jz = jk;
    return compute(x, y, jz, Q, q0, jk, jv, jx, F);
}